from pathlib import Path
from snakemake.io import expand
from snakemake.utils import listfiles


configfile: "config.yaml"


MRTRIX = config["containers"]["mrtrix"]
Ants = config["containers"]["ants"]
itk_thread_count = config["itk_threads"]
template = config["mni_template"]
bsconfig = config["bsconfig"]
bsbase = config["bsbase"]
bsmask = config["bsmask"]
model_ref = config["model_ref"]
trk_atlas = config["trk_atlas"]
base_dir = config["base_dir"]

BIDS_DIR = Path(config["bids_dir"])
# work_dir_base =  BIDS_DIR / "sub-{subject}" / "ses-{session}"
DERIVATIVES = BIDS_DIR.joinpath(config["deriv"])
# work_dir_derivatives = DERIVATIVES / "sub-{subject}" / "ses-{session}"
T1_DIR = Path(config["t1_dir"])

VALID_SUBJECT_SESSION_PAIRS = []

for sub_dir in BIDS_DIR.glob("sub-*"):
    if not sub_dir.is_dir():
        continue
    subject = sub_dir.name.split("sub-")[1]
    for ses_dir in sub_dir.glob("ses-*"):
        if not ses_dir.is_dir():
            continue
        session = ses_dir.name.split("ses-")[1]
        dwi_base = ses_dir / "dwi"
        if dwi_base.exists():
            dwi_files = list(dwi_base.rglob("*/dwmri.nii.gz"))
            if dwi_files:
                dwi_file = dwi_files[0]
                dwi_dir = dwi_file.parent
                dwi_stem = dwi_file.stem.replace(".nii", "")
                bval_file = dwi_dir / f"{dwi_stem}.bval"
                bvec_file = dwi_dir / f"{dwi_stem}.bvec"
                if not bval_file.exists():
                    alt_stem = f"sub-{subject}_ses-{session}"
                    bval_file = dwi_dir / f"{alt_stem}.bval"
                    bvec_file = dwi_dir / f"{alt_stem}.bvec"
                if bval_file.exists() and bvec_file.exists():
                    VALID_SUBJECT_SESSION_PAIRS.append((subject, session))

if VALID_SUBJECT_SESSION_PAIRS:
    VALID_SUBJECTS, VALID_SESSIONS = zip(*VALID_SUBJECT_SESSION_PAIRS)
else:
    VALID_SUBJECTS = []
    VALID_SESSIONS = []

SESSION_MAP = {}
for subject, session in VALID_SUBJECT_SESSION_PAIRS:
    if subject not in SESSION_MAP:
        SESSION_MAP[subject] = []
    SESSION_MAP[subject].append(session)

d = {
    "resample_dwi_outputs": ["sub-{subject}/ses-{session}/dwmri_1mmiso.nii.gz"],
    "compute_b0_outputs": ["sub-{subject}/ses-{session}/dwmri_b0.nii.gz"],
    "register_b0_to_t1_outputs": [
        "sub-{subject}/ses-{session}/dwmri2T1_0GenericAffine.mat",
        "sub-{subject}/ses-{session}/dwmri2T1_Warped.nii.gz",
    ],
    "transform_masks_to_dwi_outputs": [
        "sub-{subject}/ses-{session}/dwmri_mask.nii.gz",
        "sub-{subject}/ses-{session}/dwmri_seed.nii.gz",
        "sub-{subject}/ses-{session}/dwmri_5tt.nii.gz",
        "sub-{subject}/ses-{session}/dwmri_gmwmi.nii.gz",
    ],
    "fit_fod_outputs": [
        "sub-{subject}/ses-{session}/dwmri_tournier.txt",
        "sub-{subject}/ses-{session}/dwmri_fod.nii.gz",
    ],
    "convert_transform_to_mni_outputs": [
        "sub-{subject}/ses-{session}/dwmri2MNI_0GenericAffine_tfm.txt"
    ],
    "transform_fod_to_mni_outputs": [
        "sub-{subject}/ses-{session}/dwmri2MNI_0GenericAffine_tfm.trix",
        "sub-{subject}/ses-{session}/dwmri_fod_mni_trix.nii.gz",
    ],
    "convert_fod_to_signal_outputs": [
        "sub-{subject}/ses-{session}/dwmri_sf_mni_trix.nii.gz"
    ],
    "run_tractography_outputs": [
        "sub-{subject}/ses-{session}/dwmri_minlen_50.tck",
        "sub-{subject}/ses-{session}/SDStream_seeds.txt",
        "sub-{subject}/ses-{session}/parsed_SDStream_seeds.txt",
        "sub-{subject}/ses-{session}/SDStream_seeds.tck",
    ],
    "transform_tractograms_to_t1_output": [
        "sub-{subject}/ses-{session}/T1_test50to250_no_remove.trk",
        "sub-{subject}/ses-{session}/T1_SDStream_seeds.trk",
        "sub-{subject}/ses-{session}/T1_test50to250.trk",
    ],
    "transform_tractograms_to_mni_outputs": [
        "sub-{subject}/ses-{session}/T1_test50to250_mni_no_remove.trk",
        "sub-{subject}/ses-{session}/T1_SDStream_seeds_mni.trk",
        "sub-{subject}/ses-{session}/T1_test50to250_mni.trk",
    ],
    "compute_tdi_outputs": ["sub-{subject}/ses-{session}/T1_mni_tdi.nii.gz"],
    # "compute_model_to_sub_mat_outputs": [ "sub-{subject}/ses-{session}/bundleseg/model_to_sub_tfm.mat" ],
    "compute_model_to_sub_mat_outputs": ["sub-{subject}/ses-{session}/bundleseg/model_to_sub_tfm0GenericAffine.mat"],
    # "bundleseg_outputs": [
    #     "sub-{subject}/ses-{session}/bundleseg/logfile.txt",
    #     "sub-{subject}/ses-{session}/bundleseg/results.json",
    # ],
}


# TODO: REFACTOR
def all_outputs(wildcards=False):
    return [
        DERIVATIVES / p
        for k in d.keys()
        for p in expand(d[k], zip, subject=VALID_SUBJECTS, session=VALID_SESSIONS)
    ]


rule all:
    input:
        all_out=all_outputs,


def get_dwi_inputs(wildcards):
    """Get DWI input file for a specific subject-session"""
    # Validate that this is a valid pair
    if (
        wildcards.subject not in SESSION_MAP
        or wildcards.session not in SESSION_MAP[wildcards.subject]
    ):
        raise ValueError(
            f"Invalid subject-session pair: sub-{wildcards.subject}/ses-{wildcards.session}"
        )

    dwi_base = (
        BIDS_DIR / f"sub-{wildcards.subject}" / f"ses-{wildcards.session}" / "dwi"
    )
    dwi_dir = list(dwi_base.rglob("*/dwmri.nii.gz"))[0].parent
    dwi_files = list(dwi_dir.glob("dwmri.nii.gz"))
    if dwi_files:
        return dwi_files[0]
    else:
        raise Exception(
            f"No DWI files found for sub-{wildcards.subject} ses-{wildcards.session}"
        )


def get_associated_files(wildcards, suffix):
    """Get associated .bval or .bvec files"""
    # Validate that this is a valid pair
    if (
        wildcards.subject not in SESSION_MAP
        or wildcards.session not in SESSION_MAP[wildcards.subject]
    ):
        raise ValueError(
            f"Invalid subject-session pair: sub-{wildcards.subject}/ses-{wildcards.session}"
        )

    dwi_base = (
        BIDS_DIR / f"sub-{wildcards.subject}" / f"ses-{wildcards.session}" / "dwi"
    )
    dwi_dir = list(dwi_base.rglob("*/dwmri.nii.gz"))[0].parent
    dwi_files = list(dwi_dir.glob("dwmri.nii.gz"))
    if not dwi_files:
        raise Exception(
            f"No DWI files found for sub-{wildcards.subject} ses-{wildcards.session}"
        )

    dwi_stem = dwi_files[0].stem.replace(".nii", "")
    associated_file = dwi_dir / f"{dwi_stem}{suffix}"

    if not associated_file.exists():
        alt_stem = f"sub-{wildcards.subject}_ses-{wildcards.session}"
        associated_file = dwi_dir / f"{alt_stem}{suffix}"

    return associated_file


def bval(wildcards):
    return get_associated_files(wildcards, ".bval")


def bvec(wildcards):
    return get_associated_files(wildcards, ".bvec")


def output_prefix(wildcards):
    return (
        DERIVATIVES
        / f"sub-{wildcards.subject}"
        / f"ses-{wildcards.session}"
        / "dwmri2T1_"
    )


rule resample_dwmri:
    input:
        dwi=get_dwi_inputs,
    threads: 16
    output:
        DERIVATIVES / "sub-{subject}/ses-{session}/dwmri_1mmiso.nii.gz",
        # expand(DERIVATIVES / "sub-{subject}/ses-{session}/dwmri_1mmiso.nii.gz", zip, subject=VALID_SUBJECTS, session=VALID_SESSIONS)
    resources:
        io=1 
    log:
        DERIVATIVES / "logs/sub-{subject}/ses-{session}/resample_dwmri.log",
        # expand(DERIVATIVES / "logs/sub-{subject}/ses-{session}/resample_dwmri.log", zip, subject=VALID_SUBJECTS, session=VALID_SESSIONS)
    params:
        ref=template,
    shell:
        """
            flirt -in {input.dwi} -ref {params.ref} -out {output} -applyisoxfm 1.0
        """


rule compute_b0:
    input:
        dwi=rules.resample_dwmri.output,
        bval=bval,
        bvec=bvec,
    threads: 16
    output:
        b0=DERIVATIVES / "sub-{subject}/ses-{session}/dwmri_b0.nii.gz",
    params:
        base_dir = base_dir,
        container=MRTRIX,
    resources:
        io=1 
    log:
        DERIVATIVES / "logs/sub-{subject}/ses-{session}/compute_b0.log",
    container:
        MRTRIX
    shell:
        """
        # Create output and log directories
        mkdir -p $(dirname {output.b0})
        mkdir -p $(dirname {log})

        # Run pipeline with proper logging
        apptainer exec -ce -B /tmp -B {params.base_dir} -B $(dirname {output.b0}) \\
        {params.container} dwiextract {input.dwi} -fslgrad {input.bvec} \\
        {input.bval} - -bzero 2>> {log} | apptainer exec -ce -B /tmp -B {params.base_dir} -B $(dirname \\
        {output.b0}) {params.container} mrmath -in - mean {output.b0} -axis 3 \\
        2>> {log}

        """


rule register_b0_to_t1:
    input:
        b0=rules.compute_b0.output.b0,
        t1=T1_DIR / template,
    threads: 16
    output:
        affine=DERIVATIVES
        / "sub-{subject}"
        / "ses-{session}"
        / "dwmri2T1_0GenericAffine.mat",
        # Temporary, will be removed
        warped=DERIVATIVES
        / "sub-{subject}"
        / "ses-{session}"
        / "dwmri2T1_Warped.nii.gz",
    params:
        base_dir = base_dir,
        t1_dir=T1_DIR,
        output_prefix=output_prefix,
        container=Ants,
        itk_threads=itk_thread_count,
    resources:
        io=1 
    log:
        DERIVATIVES / "logs/sub-{subject}/ses-{session}/register_t1_to_b0.log",
    container:
        Ants
    shell:
        """
        # Create output and log directories
        mkdir -p $(dirname {output.affine})
        mkdir -p $(dirname {log})

        # Run registration with proper logging
        apptainer exec -ce -B {params.base_dir} -B {params.t1_dir} \\
        -B $(dirname {output.affine}) \\
        --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} antsRegistrationSyN.sh -d 3 -m {input.b0} \\
        -f {input.t1} -t r -o {params.output_prefix} 2>> {log}
        """


rule transform_masks_to_dwi:
    input:
        b0=rules.compute_b0.output.b0,
        affine=rules.register_b0_to_t1.output.affine,
        t1_mask=T1_DIR / "T1_mask.nii.gz",
        t1_seed=T1_DIR / "T1_seed.nii.gz",
        t1_5tt=T1_DIR / "T1_5tt.nii.gz",
        t1_gmwmi=T1_DIR / "T1_gmwmi.nii.gz",
    threads: 16
    output:
        dwi_mask=DERIVATIVES / "sub-{subject}" / "ses-{session}" / "dwmri_mask.nii.gz",
        dwi_seed=DERIVATIVES / "sub-{subject}" / "ses-{session}" / "dwmri_seed.nii.gz",
        dwi_5tt=DERIVATIVES / "sub-{subject}" / "ses-{session}" / "dwmri_5tt.nii.gz",
        dwi_gmwmi=DERIVATIVES / "sub-{subject}" / "ses-{session}" / "dwmri_gmwmi.nii.gz",
    params:
        t1_dir=T1_DIR,
        base_dir=base_dir,
        container=Ants,
        itk_threads=itk_thread_count,
    resources:
        io=1 
    log:
        DERIVATIVES / "logs/sub-{subject}/ses-{session}/transform_masks_to_dwi.log",
    container:
        Ants
    shell:
        """
        # Create output and log directories
        mkdir -p $(dirname {output.dwi_mask})
        mkdir -p $(dirname {log})

        # Transform brain mask
        apptainer exec -ce -B {params.base_dir} -B {params.t1_dir} \\
        -B $(dirname {output.dwi_mask}) \\
        --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} antsApplyTransforms -d 3 -e 0 -r {input.b0} \\
        -i {input.t1_mask} -t [{input.affine},1] -o {output.dwi_mask} \\
        -n NearestNeighbor 2>> {log}

        # Transform seed mask
        apptainer exec -ce -B {params.base_dir} -B {params.t1_dir} \\
        -B $(dirname {output.dwi_seed}) \\
        --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} antsApplyTransforms -d 3 -e 0 -r {input.b0} \\
        -i {input.t1_seed} -t [{input.affine},1] -o {output.dwi_seed} \\
        -n NearestNeighbor 2>> {log}

        # Transform 5tt image
        apptainer exec -ce -B {params.base_dir} -B {params.t1_dir} \\
        -B $(dirname {output.dwi_5tt}) \\
        --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} antsApplyTransforms -d 3 -e 3 -r {input.b0} \\
        -i {input.t1_5tt} -t [{input.affine},1] -o {output.dwi_5tt} \\
        -n Linear 2>> {log}

        # Transform GM-WM interface
        apptainer exec -ce -B {params.base_dir} -B {params.t1_dir} \\
        -B $(dirname {output.dwi_gmwmi}) \\
        --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} antsApplyTransforms -d 3 -e 0 -r {input.b0} \\
        -i {input.t1_gmwmi} -t [{input.affine},1] -o {output.dwi_gmwmi} \\
        -n Linear 2>> {log}
        """


rule fit_fod:
    input:
        dwi=rules.resample_dwmri.output,
        bval=bval,
        bvec=bvec,
        dwi_mask=rules.transform_masks_to_dwi.output.dwi_mask,
    threads: 16
    output:
        response=DERIVATIVES / "sub-{subject}" / "ses-{session}" / "dwmri_tournier.txt",
        fod=DERIVATIVES / "sub-{subject}" / "ses-{session}" / "dwmri_fod.nii.gz",
    params:
        base_dir = base_dir,
        container=MRTRIX,
        itk_threads=itk_thread_count,
    resources:
        io=1 
    log:
        DERIVATIVES / "logs/sub-{subject}/ses-{session}/fit_fod.log",
    container:
        MRTRIX
    shell:
        """
        # Create output and log directories
        mkdir -p $(dirname {output.response})
        mkdir -p $(dirname {log})

        # Fit response function
        apptainer exec -B {params.base_dir} -B $(dirname {input.dwi}) \\
        -B $(dirname {output.response}) \\
        --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} dwi2response tournier {input.dwi} \\
        {output.response} -fslgrad {input.bvec} {input.bval} \\
        -mask {input.dwi_mask} 2>> {log}

        # Fit FOD
        apptainer exec -B {params.base_dir} -B $(dirname {input.dwi}) \\
        --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} dwi2fod csd {input.dwi} {output.response} \\
        {output.fod} -fslgrad {input.bvec} {input.bval} \\
        -mask {input.dwi_mask} 2>> {log}
        """


rule convert_transform_to_mni:
    input:
        dwi2t1_affine=rules.register_b0_to_t1.output.affine,
    threads: 16
    output:
        dwi2mni_txt=DERIVATIVES
        / "sub-{subject}/ses-{session}/dwmri2MNI_0GenericAffine_tfm.txt",
    params:
        base_dir = base_dir,
        container=Ants,
        itk_threads=itk_thread_count,
    log:
        DERIVATIVES / "logs/sub-{subject}/ses-{session}/convert_transform_to_mni.log",
    resources:
        io=1 
    container:
        Ants
    shell:
        """
        # Create output and log directories
        mkdir -p $(dirname {output.dwi2mni_txt})
        mkdir -p $(dirname {log})

        # Convert DWI-to-T1 affine transform to text format
        apptainer exec -B {params.base_dir} \\
        -B $(dirname {input.dwi2t1_affine}) -B $(dirname {output.dwi2mni_txt}) \\
        --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} ConvertTransformFile 3 {input.dwi2t1_affine} \\
        {output.dwi2mni_txt} 2>> {log}
        """


rule transform_fod_to_mni:
    input:
        fod=rules.fit_fod.output.fod,
        mni_template=T1_DIR / template,
        dwi2mni_txt=rules.convert_transform_to_mni.output.dwi2mni_txt,
    threads: 16
    output:
        dwi2mni_trix=DERIVATIVES
        / "sub-{subject}/ses-{session}/dwmri2MNI_0GenericAffine_tfm.trix",
        fod_mni=DERIVATIVES / "sub-{subject}/ses-{session}/dwmri_fod_mni_trix.nii.gz",
    params:
        base_dir = base_dir,
        container=MRTRIX,
        itk_threads=itk_thread_count,
    resources:
        io=1 
    log:
        DERIVATIVES / "logs/sub-{subject}/ses-{session}/transform_fod_to_mni.log",
    container:
        MRTRIX
    shell:
        """
        # Create output and log directories
        mkdir -p $(dirname {output.fod_mni})
        mkdir -p $(dirname {output.dwi2mni_trix})
        mkdir -p $(dirname {log})
        # Convert text transform to MRtrix format - FIX: use input.dwi2mni_txt not output
        apptainer exec -B {params.base_dir} \\
        --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} transformconvert {input.dwi2mni_txt} \\
        itk_import {output.dwi2mni_trix} 2>> {log} #noqa
        # MISSING LINES 50-51?
        # 52 is split into two separate commands below.

        # Transform FOD to MNI space with proper reorientation
        apptainer exec -B {params.base_dir} -B $(dirname {input.fod}) \\
        -B $(dirname {input.mni_template}) -B $(dirname {output.fod_mni}) \\
        --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} mrtransform {input.fod} \\
        -linear {output.dwi2mni_trix} -template {input.mni_template} \\
        -interp linear -modulate fod -reorient_fod true {output.fod_mni}

        apptainer exec -B {params.base_dir} \\
        -B $(dirname {input.mni_template}) \\
        --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} mrtransform -linear {output.dwi2mni_trix} \\
        -interp linear -template {input.mni_template} -stride 1,2,3 \\
        -modulate fod -force -reorient_fod true {output.fod_mni} \\
        {output.fod_mni}
        """


rule convert_fod_to_signal:
    input:
        fod_mni=rules.transform_fod_to_mni.output.fod_mni,
    threads: 16
    output:
        sf_mni=DERIVATIVES
        / "sub-{subject}"
        / "ses-{session}"
        / "dwmri_sf_mni_trix.nii.gz",
    params:
        base_dir = base_dir,
    resources:
        io=1 
    shell:
        """
        scil_sh_to_sf --sh_basis tournier07 --sphere repulsion100 \\
        {input.fod_mni} {output.sf_mni}
        """


rule run_tractography:
    input:
        fod=rules.fit_fod.output.fod,
        # fod = rules.transform_fod_to_mni.output.fod_mni,
        dwi_mask=rules.transform_masks_to_dwi.output.dwi_mask,
        # t1_mask = T1_DIR / "T1_mask.nii.gz",
        dwi_gmwmi = rules.transform_masks_to_dwi.output.dwi_gmwmi,
        # t1_mask = T1_DIR / template,
        dwi_seed=rules.transform_masks_to_dwi.output.dwi_seed,
        # t1_5tt = T1_DIR / "T1_5tt.nii.gz",
        dwi_5tt=rules.transform_masks_to_dwi.output.dwi_5tt,
    threads: 8
    output:
        tck=DERIVATIVES / "sub-{subject}" / "ses-{session}" / "dwmri_minlen_50.tck",
        seeds_txt=DERIVATIVES / "sub-{subject}" / "ses-{session}" / "SDStream_seeds.txt",
        seeds_parsed=DERIVATIVES
        / "sub-{subject}"
        / "ses-{session}"
        / "parsed_SDStream_seeds.txt",
        seeds_tck=DERIVATIVES / "sub-{subject}" / "ses-{session}" / "SDStream_seeds.tck",
    params:
        base_dir = base_dir,
        container=MRTRIX,
        itk_threads=itk_thread_count,
    resources:
        io=1 
    log:
        DERIVATIVES / "logs/sub-{subject}/ses-{session}/run_tractography.log",
    container:
        MRTRIX
    shell:
        """
        # Create output and log directories
        mkdir -p $(dirname {output.tck})
        mkdir -p $(dirname {log})

        # Run tractography with proper logging
        apptainer exec -B {params.base_dir} --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} tckgen {input.fod} {output.tck} \\
        -algorithm SD_Stream -select 1000000 -step .1 -seed_image \\
        {input.dwi_seed} -seed_gmwmi {input.dwi_gmwmi} -crop_at_gmwmi \\
        -mask {input.dwi_mask} -minlength 50 -act {input.dwi_5tt} \\
        -output_seeds {output.seeds_txt} -info -force 2>> {log}

        # Parse seeds file with error checking
        if [ -f {output.seeds_txt} ]; then
            echo "LINE 646"
            tail -n +3 {output.seeds_txt} | \\
            cut -d "," -f 3- > {output.seeds_parsed} 2>> {log}
        else
            echo "ERROR: Seeds file {output.seeds_txt} not generated" >> {log}
            exit 1
        fi

        # Convert to TCK format with proper bind mounts
        apptainer exec -B {params.base_dir} \\
        -B $(dirname {output.seeds_parsed}) -B $(dirname {output.seeds_tck}) \\
        --env "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} tckconvert {output.seeds_parsed} \\
        {output.seeds_tck} 2>> {log}

        # Verify outputs were created
        if [ ! -f {output.tck} ] || [ ! -f {output.seeds_tck} ]; then
            echo "ERROR: Tractography outputs not fully generated" >> {log}
            exit 1
        fi
        """


rule transform_tractograms_to_t1:
    input:
        b0=rules.compute_b0.output.b0,
        tck=rules.run_tractography.output.tck,
        seeds_tck=rules.run_tractography.output.seeds_tck,
        t1_n4=T1_DIR / "T1_N4.nii.gz",
        dwi2t1_affine=rules.register_b0_to_t1.output.affine,
    threads: 16
    output:
        tck_t1_no_remove=DERIVATIVES
        / "sub-{subject}"
        / "ses-{session}"
        / "T1_test50to250_no_remove.trk",
        seeds_t1=DERIVATIVES
        / "sub-{subject}"
        / "ses-{session}"
        / "T1_SDStream_seeds.trk",
        tck_t1=DERIVATIVES / "sub-{subject}" / "ses-{session}" / "T1_test50to250.trk",
    params:
        base_dir=base_dir,
    resources:
        io=1 
    shell:
        """
        # Transform main tractogram to T1 space (no removal)
        scil_tractogram_apply_transform --reference {input.b0} {input.tck} \\
        {input.t1_n4} {input.dwi2t1_affine} {output.tck_t1_no_remove} \\
        --inverse -f

        # Transform seeds to T1 space
        scil_tractogram_apply_transform --reference {input.b0} \\
        {input.seeds_tck} {input.t1_n4} {input.dwi2t1_affine} \\
        {output.seeds_t1} --inverse -f

        # Transform main tractogram to T1 space (with removal)
        scil_tractogram_apply_transform  --reference {input.b0} {input.tck} \\
        {input.t1_n4} {input.dwi2t1_affine} {output.tck_t1} --inverse \\
        --remove_invalid
        """


rule transform_tractograms_to_mni:
    input:
        tck_t1=rules.transform_tractograms_to_t1.output.tck_t1,
        seeds_t1=rules.transform_tractograms_to_t1.output.seeds_t1,
        t1_n4_mni=T1_DIR / "T1_N4_mni_1mm.nii.gz",
        t12mni_affine=T1_DIR / "mni_t1_0GenericAffine.mat",
    threads: 16
    output:
        tck_mni_no_remove=DERIVATIVES
        / "sub-{subject}"
        / "ses-{session}"
        / "T1_test50to250_mni_no_remove.trk",
        seeds_mni=DERIVATIVES
        / "sub-{subject}"
        / "ses-{session}"
        / "T1_SDStream_seeds_mni.trk",
        tck_mni=DERIVATIVES
        / "sub-{subject}"
        / "ses-{session}"
        / "T1_test50to250_mni.trk",
    params:
        base_dir=base_dir,
    resources:
        io=1 
    shell:
        """
        # Transform main tractogram to MNI space (no removal)
        scil_tractogram_apply_transform \\
            {input.tck_t1} {input.t1_n4_mni} {input.t12mni_affine} \\
            {output.tck_mni_no_remove} --inverse -f

        # Transform seeds to MNI space
        scil_tractogram_apply_transform \\
            {input.seeds_t1} {input.t1_n4_mni} {input.t12mni_affine} \\
            {output.seeds_mni} --inverse -f

        # Transform main tractogram to MNI space (with removal)
        scil_tractogram_apply_transform \\
            {input.tck_t1} {input.t1_n4_mni} {input.t12mni_affine} \\
            {output.tck_mni} --inverse --remove_invalid
        """


rule compute_tdi:
    input:
        tck_mni=rules.transform_tractograms_to_mni.output.tck_mni,
    threads: 16
    output:
        tdi=DERIVATIVES / "sub-{subject}" / "ses-{session}" / "T1_mni_tdi.nii.gz",  # "T1_test50to250_mni_tdi.nii.gz",
    params:
        base_dir=base_dir,
    resources:
        io=1 
    shell:
        """
        scil_tractogram_compute_density_map \\
            {input.tck_mni} {output.tdi}
        """


rule compute_model_to_sub_mat:
    input:
        b0=rules.compute_b0.output.b0,
        model_ref=model_ref,
    threads: 16
    output:
        mat = DERIVATIVES / "sub-{subject}"/ "ses-{session}" / "bundleseg/model_to_sub_tfm0GenericAffine.mat",
    params:
        base_dir = base_dir,
        container=Ants,
        itk_threads=itk_thread_count,
        bsmask = bsmask
    resources:
        io=1 
    container:
        Ants
    shell:
        """
        apptainer exec -c -e -B {params.base_dir} -B {params.bsmask} --env \\
        "ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS={params.itk_threads}" \\
        {params.container} antsRegistrationSyN.sh  -d 3 -m {input.model_ref} \\
        -f {input.b0} -t a -n 4 -o $(dirname {output.mat})/model_to_sub_tfm
        """


rule bundleseg:
    input:
        tck=rules.run_tractography.output.tck,
        trk_atlas=trk_atlas,
        tck_ref=rules.compute_b0.output.b0,
        config=bsconfig,
        model_to_subj_tfm=rules.compute_model_to_sub_mat.output.mat,
    threads: 16
    resources:
        io=1 
    output:
        logfle = DERIVATIVES / "sub-{subject}"/ "ses-{session}"  / "bundleseg/logfile.txt",
        results = DERIVATIVES / "sub-{subject}"/ "ses-{session}"  / "bundleseg/results.json",
    params:
        bids_dir =  DERIVATIVES / "sub-{subject}"/ "ses-{session}",
        processes=itk_thread_count
    shell:
        """
        scil_tractogram_segment_with_bundleseg {input.tck} {input.config} \\
        {input.trk_atlas}/* {input.model_to_subj_tfm} \\
        --reference {input.tck_ref} \\
        --out_dir {params.bids_dir}/bundleseg -v DEBUG --minimal_vote 0.1 \\
        --processes {params.processes} --seed 0 --exploration_mode -f
        """
